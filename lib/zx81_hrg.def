;       CRT0 for the ZX81 - HIGH RESOLUTION MODE (WRX trick by Wilf Rigter)
;
;       This code comes from the 'HRG_Tool'  by Matthias Swatosch
;       Display handler modifications (to preserve IY) by Stefano Bodrato
;
;
; - - - - - - -
;
;       $Id: zx81_hrg.def,v 1.12 2007/11/02 16:50:37 stefano Exp $
;
; - - - - - - -

XDEF	hrg_on
XDEF	hrg_off

IF (startup>=5)
 IF (startup=7)
  IF DEFINED_MEM8K
    DEFC  TOPOFRAM    = $6000
    DEFC  BASE_VRAM   = $5000
    DEFC  NEW_RAMTOP  = $4F80
  ELSE
    DEFC  TOPOFRAM    = $8000
    DEFC  BASE_VRAM   = $7000
    DEFC  NEW_RAMTOP  = $6F80
  ENDIF
    DEFC  WHOLEMEM    = 4096+128   ; size of graphics map in grayscale mode
 ELSE
  IF DEFINED_MEM8K
    DEFC  TOPOFRAM    = $6000
    DEFC  BASE_VRAM   = $5800
    DEFC  NEW_RAMTOP  = $5780
  ELSE
    DEFC  TOPOFRAM    = $8000
    DEFC  BASE_VRAM   = $7800
    DEFC  NEW_RAMTOP  = $7780
  ENDIF
    DEFC  WHOLEMEM    = 2048+128   ; size of graphics map in 256x64 mode
 ENDIF
ELSE
 IF DEFINED_MEM8K
    DEFC  TOPOFRAM    = $6000
    DEFC  BASE_VRAM   = $4800
    DEFC  NEW_RAMTOP  = $4780
 ELSE
    DEFC  TOPOFRAM    = $8000
    DEFC  BASE_VRAM   = $6800
    DEFC  NEW_RAMTOP  = $6780
 ENDIF
    DEFC  WHOLEMEM    = 6144+128   ; size of graphics map in 256x192 mode
ENDIF

IF ((startup=3)|(startup=5))
.hrgbrkflag
        defb    0
ENDIF

;--------------------------------------------------------------
;--------------------------------------------------------------

;------------------------------------------
;
;   ZX81 system variables
;
;------------------------------------------
;DEFC   ERR_NR  = 16384 ;byte   one less than the report code
;DEFC   FLAGS   = 16385 ;byte   flags to control the BASIC system.
;DEFC   MODE    = 16390 ;byte   Specified K, L, F or G cursor.
;DEFC   PPC     = 16391 ;word   Line number of statement currently being executed

DEFC    ERR_SP  = 16386 ;word   Address of first item on machine stack (after GOSUB returns).
DEFC    RAMTOP  = 16388 ;word   Address of first byte above BASIC system area. 


;----------------------------------------------------------------
;
; Switch to HRG mode 
; "base_graphics" has to point to a reasonable adress
;
;----------------------------------------------------------------
hrg_on:
	call   $F2B	; SLOW
IF !DEFINED_hrgpage
        ld      hl,(base_graphics)
        ld      a,h
        or      l
        call    z,HRG_Interface_BaseRamtop	; if zero, make space and adjust ramtop for 16K
ENDIF
IF (startup=7)
        ld      hl,(base_graphics)
        ld	(graybit1),hl
	ld	de,2048
	add	hl,de
	ld	(graybit2),hl
        ld	(current_graphics),hl
ENDIF
	call	HRG_Sync
        ld      iy,HRG_handler  ; starts the hires mode when JP (IX) is made
        ret

;----------------------------------------------------------------
;
; Switch to TXT mode
;
;----------------------------------------------------------------
hrg_off:
	call	HRG_Sync
        ld      iy,$281    ; switch back to text (original video routine)
        ld      a,$1e
        ld      i,a
        ret

;----------------------------------------------------------------
;
; Sync display before mode switching
;
;----------------------------------------------------------------
HRG_Sync:
        ld      hl,$4034        ; FRAMES counter
        ld      a,(hl)          ; get old FRAMES
HRG_Sync1:
        cp      (hl)            ; compare to new FRAMES
        jr      z,HRG_Sync1     ; exit after a change is detected
        ret

;----------------------------------------------------------------
;
; This is the HRG handler
;
;----------------------------------------------------------------
;calculation of label above 32k

HRG_handler:
        ld      b,6             ; delay sets the left edge of the screen
HRG_wait_left:
        djnz    HRG_wait_left   ; delay loop
        ld hl,0                 ; delay fine tuning here! Do not change!
        nop                     ; delay fine tuning here! Do not change!

        dec     b               ; make Z flag=0
IF (startup=7)
        ld      hl,(current_graphics)
ELSE
        ld      hl,(base_graphics)
ENDIF

        ld      de,32           ; 32 bytes offset is added to HL for next hline
IF (startup>=5)
        ld      b,64            ; 64 lines per hires screen
ELSE
        ld      b,192            ; 192 lines per hires screen
ENDIF

HRG_outloop:
        ld      a,h             ; get HGR address MSB from HL
        ld      i,a             ; load MSB into I register which is RFSH address MSB
        ld      a,l             ; get HGR address LSB from HL
        call    (HRG_LineStart + $8000)
        add     hl,de           ; add 32 to HL to point to next hline
        dec     b               ; decrement line counter
        jp      nz,HRG_outloop  ; test for last line

	ld	hl,(frames)	; clock handler
        inc	hl
        ld	(frames),hl
        ld	a,h
        or	l
        jp	nz,nofr1
        ld	hl,frames+1
        inc	(hl)
.nofr1

        ;call   $0292          ; return to application program

; Different from original call to keep IY unchanged
; and to eventually add blank lines

        ld      iy,pointedbyix ; in ROM we'd have had a POP IX and JP IX as a 'return'
        ld      a,(16424)      ; MARGIN

; this idea comes from the Wilf Rigter's WRX1K hi-resolution implementation
; if we run in 64 lines mode we need to increase the number of border's lines

IF (startup>=5)
        add     140             ; more blank lines for fast application code and correct sync
        			; Siegfried Engel reports that values between 80 and 159 worked
        			; fine on both a normal TV and an LCD one
ENDIF

        ld      c,a            ; load C with MARGIN
        ld      a,(16443)      ; test CDFLAG
        bit     7,a

        jp      $29b           ; save blank lines, start NMI, POP registers and RETURN

pointedbyix:        
        push    ix
        ld      ix,16384

        call    $0220          ; first PUSH register, then do VSYNC and get KEYBD

IF ((startup=3)|(startup=5))
        call    $0F46          ; check break (space) key
        jp      c,nobrkk
        ld      a,(hrgbrkflag)     ; set to '0' if program isn't running
        and	a
        jr	z,nobrkk
        SCF
.nobrkk
ENDIF

        pop     ix

IF ((startup=3)|(startup=5))
        ld      a,$1e           ; the I register is restored with the MSB address
        ld      i,a             ; of the ROM pattern table in case of BREAK key down

        jp      nc,$02A4
ENDIF

IF (startup=7)
	ld	hl,gcount
	;res	7,(hl)
	inc	(hl)
	ld	a,(hl)
	dec	a
	jp	z,Display_pic1
	dec	a
	jp	z,Display_pic2
	ld	(hl),0
Display_pic1:
	ld	hl,(graybit1)
	jp	setpage
Display_pic2:
	ld	hl,(graybit2)
setpage:
	ld	(current_graphics),hl
ENDIF

        ld      iy,HRG_handler  ; reload vector if no BREAK or else SINCLAIR video
        jp      $02A4           ; now return to BASIC and other application programs

;----------------------------------------------------------------
;  Variables for grayscale graphics
;----------------------------------------------------------------

IF (startup=7)
		XDEF	graybit1
		XDEF	graybit2
gcount:
		defb	0
current_graphics:
		defw	0
graybit1:
		defw	0
graybit2:
		defw	0
ENDIF

;----------------------------------------------------------------
;
; This is a dummy-line used for HRG output
;
;----------------------------------------------------------------
HRG_LineStart:
        ld      r,a             ; load LSB to R register which is RFSH address LSB
        defb    0, 0, 0, 0      ; 32 NOPs = 32x8 bits = 256 pixels each HLINE
        defb    0, 0, 0, 0
        defb    0, 0, 0, 0
        defb    0, 0, 0, 0
        defb    0, 0, 0, 0
        defb    0, 0, 0, 0
        defb    0, 0, 0, 0
        defb    0, 0, 0, 0
        ret     nz              ; always returns because Z flag=0

;----------------------------------------------------------------
;
; End of HRG handler
;
;----------------------------------------------------------------


IF !DEFINED_hrgpage
;--------------------------------------------------------------
;
; HRG_Interface_BaseRamtop
;
; checks if RAMTOP is set to 16k ram pack
; if so it lowers RAMTOP, copies stack and adapts all
; needed variables so that the program can coninue without
; NEW.
; And of course it sets HRG base to the location over
; RAMTOP
;
;--------------------------------------------------------------
HRG_Interface_BaseRamtop:

        ld      hl,(RAMTOP)
        ld      de,TOPOFRAM     ;is RAMTOP in original 8k/16k position?
        xor     a
        sbc     hl,de
        ld      a,h
        or      l
        jr      z,HRG_Interface_BaseRamtopModify
        ld      hl,(RAMTOP)
        ld      de,NEW_RAMTOP    ;is RAMTOP already lowered?
        xor     a
        sbc     hl,de
        ld      a,h
        or      l               ;no, so this is a problem!
        jr      nz,HRG_Interface_BaseRamError

        ld      hl,BASE_VRAM      ;yes, then set base_graphics
        ld      (base_graphics),hl
        ret


HRG_Interface_BaseRamtopModify: 
        ld      hl,BASE_VRAM
        ld      (base_graphics),hl

        ld      hl,NEW_RAMTOP    ;lower RAMTOP
        ld      (RAMTOP),hl
        
        ld      hl,(ERR_SP)
        ld      de,WHOLEMEM
        xor     a
        sbc     hl,de
        ld      (ERR_SP),hl     ;lower ERR_SP


        ld      hl,$0000
        add     hl,sp           ;load SP into HL
        push    hl		; *** stack pointer
        ld      de,TOPOFRAM     ;prepare to copy the stack
        ex      de,hl
        xor     a
        sbc     hl,de
        ld      de,$0040
        add     hl,de           ;stackdeepth in HL
        push    hl
        pop     bc              ;stackdeepth in BC
        
        ld	hl,TOPOFRAM-1   ;make a copy of the stack
        ld      de,NEW_RAMTOP-1
        lddr

        pop     hl              ; *** stackpointer in HL
        ld      de,WHOLEMEM
        xor     a
        sbc     hl,de           ;lower the stackpointer
        ld      sp,hl           ;WOW!


HRG_Interface_BaseRamError:

        ;rst     $08             ;error
        ;defb    $1a             ;type R

	; Nothig is as expected: let's put graphics just above the actual RAMTOP
	; and cross fingers

        ld      hl,(RAMTOP)
        ld      (base_graphics),hl
        
        ret

ENDIF
